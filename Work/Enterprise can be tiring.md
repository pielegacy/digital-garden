I'm in a very privileged position where I've managed to make money doing something I love. This is (hopefully) the case with many software engineers, and is a reality that is accessible to many people in the industry.
This good will is often abused - you've surely seen a screenshot of an insufferable job description requiring that only _"the most driven"_ apply, had a hiring manager ask about your latest "side hustle". Often times you're probably working an extra few hours a week by accident through continuous efforts to get those PRs across the line.
People often ask if moving into management has been tough as I'm *"not on the tools"* as much as I used to be. From personal experience, my work very much becoming a job and my hobby of coding moving more into something I really do in my spare time has been fantastic for my enjoyment of the activity. Most professions are not something you can do in your spare time, unlike programming. 
Being able to refine your skill set so easily in your spare time results in a growth pattern where the people who can harness a love for coding will grow fast but are hit the hardest by the grim reality that being paid to do what you love can suck a lot of the enjoyment out of it. Yes I know, shockingly enough work is not fun in nature. It can be exciting, interesting, provide purpose - but I personally don't prescribe to the belief that *"if you love what you do, you won't work a day in your life"*.

Enterprise software development is a different beast. What is *"Enterprise"* can mean different things to different people but for the sake of this article just assume an office job for a medium to large company. Emphasis on the medium here, as it does seem in this in-between state of a company that doing things a way that is Enterprise becomes something that matters more and more.

To *circle back* (sorry) to the original point, I believe most companies with enough money to do so will overcook their tech stack. Like Enterprise, this can mean different things in different contexts. In my current company, our sales are a blend of online and in-store so I know that for a good chunk of the business software is just a thing which is installed and used to support retail. Point of Sale, Warehouse Management, and Enterprise Resource Planning software differ greatly in how they're managed and rolled out when compared to one of the various Web APIs which support the web store. Especially with anything fulfilment related, you are dealing with some very real challenges that cannot just be remedied with better engineering and so implementing or modifying these systems does required thorough stages of planning and a more conservative approach to the whole software development lifecycle entirely. Poor technical decisions with this kind of tech aren't just something that can be hotfixed or feature flagged; rolling out a bad patch to every store back of house device in the country is much harder to undo when compared to a bad container image. 

My frustrations come with an obsession of hypothetical scenarios disguised as architectural futureproofing. This is a massive source of imposter syndrome for me as I am constantly asking myself "am I oversimplifying this?" - it's hard not to think when so many ideas are put forward which you internally deem as too complicated that you may be just be a bit dumb. 
This may be one that's a bit too close to home as I deliver software at a company which is not a software company - we write .NET services that gets makeup to people. 
Whilst I'm sure many people from my job would probably disagree - many ecommerce businesses are not making money off their tech and in so many cases engineering is a loss. A good way to mitigate this is to ensure that *when* something is being built, it's going to work for a very long time before a refresh is needed. It's an admirable North Star but personally I find these rules of engagement to be where the headaches arise. Solutions that could easily have been achieved by getting a couple of devs to write an API with a database which will probably be prod ready in a few sprints becomes a series of RFCs, KDDs, ideation sessions, t-shirt sizing which means you've spent more time planning this work than it would've taken to just build it and iterate when issues arise. The worst part of this is even typing it out - the former can be a recipe for disaster and there is a need to ensure necessary preparations take place. 

Maybe you will land on the same solution during this planning phase that you would've gone with anyway - but that's highly unlikely if you've approached it with the "ASP.NET Core Web API + Postgres Database" boilerplate I have committed to memory. After all, nothing is more future proof than writing as little code as possible - and we definitely shouldn't be writing SQL queries **from scratch**. What seems so simple on paper when you're willing to build a few controllers is actually very complicated and needs to be be supplemented through a variety of off the shelf, low-code solutions. As was the case with the previous fork on the road, I know why we do this. As much as I'd love to own my stack, there are times where the managed service is the correct call. As developers we agree never to roll our own auth, the boundaries are bound to shift into the realm of "do we really need to reimplement search?". 
Don't forget these alternatives are all on an enshittification timer - you're right to assume they will become exorbitantly expensive and you'll either pay it or put in enough dev work to curb the costs that you probably should've just built it yourself in the first place. You will never hate something as much as businesses hate code. 

*We've not even started building yet.*

*What are we doing here.* 